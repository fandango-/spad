--  mex.spad
--
--  Copyright 2015 Abhinav Baid
--
--  This program is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program; if not, write to the Free Software
--  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
--  MA 02110-1301, USA.
--
--


rep x ==> (x@%) pretend Rep
per x ==> (x@Rep) pretend %
Z ==> Integer
Q ==> Fraction Z
C ==> Complex Q
X ==> Expression C
D ==> Product(String, List %)

)abbrev category MABMON MAbelianAdditiveMonoid
MAbelianAdditiveMonoid : Category == SetCategory with
    0 : %
    _+ : (%, %) -> %

)abbrev category MABAGRP MAbelianAdditiveGroup
MAbelianAdditiveGroup : Category == MAbelianAdditiveMonoid with
    _- : % -> %
    _- : (%, %) -> %
  add
    ((x : %) - (y : %)) : % == x + (-y)

)abbrev category MMMON MMultiplicativeMonoid
MMultiplicativeMonoid : Category == SetCategory with
    1 : %
    _* : (%, %) -> %

)abbrev category MABMMON MAbelianMultiplicativeMonoid
MAbelianMultiplicativeMonoid : Category == MMultiplicativeMonoid

)abbrev category MRING MRing
MRing : Category == Join(MAbelianAdditiveGroup, MMultiplicativeMonoid)

)abbrev category MCRING MCommutativeRing
MCommutativeRing : Category == Join(MRing, MAbelianMultiplicativeMonoid)

)abbrev category MINTDOM MIntegralDomain
MIntegralDomain : Category == MCommutativeRing

)abbrev category MFIELD MField
MField : Category == MIntegralDomain with
    inv : % -> %
    _/ : (%, %) -> %
    _^ : (%, Integer) -> %
  add
    inv(x: %) : % == 1/x

)abbrev category MEXCAT MExpressionCategory
MExpressionCategory : Category == MField with
    coerce : % -> X
    coerce : Z -> %
    coerce : Q -> %
    coerce : Complex Z -> %
    coerce : Complex Q -> %
    coerce : Symbol -> %
    variable? : % -> Boolean
    complex? : % -> Boolean
    _= : (%, %) -> Boolean
    decompose : % -> Product(String, List %)
    _^ : (%, %) -> %
    sqrt : % -> %
    sin : % -> %
    cos : % -> %
    exp : % -> %
    log : % -> %
    tan : % -> %
    cot : % -> %
    asin : % -> %
    acos : % -> %
    atan : % -> %
    acot : % -> %

)abbrev domain MEX MExpression
MExpression : MExpressionCategory == add
    Rep ==> X

    coerce(a : %) : X == a pretend X
    coerce(a : %) : OutputForm == coerce rep a
    coerce(z : Z) : % == per(z::X)
    coerce(q : Q) : % == per(q::X)
    coerce(c : C) : % == per(c::X)
    coerce(c : Complex Z) : % == complex(real(c)::Q, imag(c)::Q)$C::%
    coerce(s: Symbol) : % == per(s::X)
    variable?(x : %) : Boolean == empty? second decompose x
    complex?(a : %) : Boolean == number? rep a
    0 : % == (0$Z)::%
    1 : % == (1$Z)::%
    ((a : %) = (b : %)) : Boolean == rep a = rep b

    _-(a : %) : % == per(- rep a)
    ((a : %) + (b : %)) : % == per(rep a + rep b)
    ((a : %) * (b : %)) : % == per(rep a * rep b)
    ((a : %) / (b : %)) : % == per(rep a / rep b)
    ((a : %) ^ (z : Z)) : % == per(rep a ^ z)
    ((a : %) ^ (b : %)) : % == per(rep a ^ rep b)
    sqrt(a : %) : % == per sqrt rep a
    sin(a : %) : % == per sin rep a
    cos(a : %) : % == per cos rep a
    exp(a : %) : % == per exp rep a
    log(a : %) : % == per log rep a
    tan(a : %) : % == per tan rep a
    cot(a : %) : % == per cot rep a
    asin(a : %) : % == per asin rep a
    acos(a : %) : % == per acos rep a
    atan(a : %) : % == per atan rep a
    acot(a : %) : % == per acot rep a

    decompose(a : %) : D ==
        complex? a ==> ["complex", [a]]$D
        ra := rep a
        il := isPlus ra
        il case List(X) => ["+", (il::List(X)) pretend List(%)]$D
        il := isTimes ra
        il case List(X) => ["*", (il::List(X)) pretend List(%)]$D
        ip := isPower ra
        ip case Record(val : X, exponent : Z) and ip.exponent ~= 1 =>
            ["^", [ip.val, (ip.exponent)::X] pretend List(%)]$D
        ks : List(Kernel X) := kernels ra
        #(ks) ~= 1 =>
            print("decompose : more than one kernel detected"::OutputForm)
            print(ra::OutputForm)
            print(ks::OutputForm)
            error "decompose error"
        k : Kernel(X) := first ks
        [string name k, [per z for z in argument k]]$D

