--  sequence.spad
--
--  Copyright 2015 Abhinav Baid
--
--  This program is free software; you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation; either version 2 of the License, or
--  (at your option) any later version.
--
--  This program is distributed in the hope that it will be useful,
--  but WITHOUT ANY WARRANTY; without even the implied warranty of
--  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
--  GNU General Public License for more details.
--
--  You should have received a copy of the GNU General Public License
--  along with this program; if not, write to the Free Software
--  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
--  MA 02110-1301, USA.
--
--


SI ==> SingleInteger
LSI ==> List SI
PSI ==> PrimitiveArray SI

)abbrev package TTT TTT
TTT : with (
    list_map1 : (LSI, SI -> SI) -> LSI;
      ++ list_map1([e1, ..., en], f) returns
      ++ \spad{[f(e1), ..., f(en)]}
    list_inc : LSI -> LSI;
      ++ list_inc([e1, ..., en]) returns \spad{[e1+1, ..., en+1]}
      ++ Note: we create a fresh list
    arr_inc : PSI -> PSI;
      ++ similar to list_inc for arrays
    list_fill : (LSI, SI) -> LSI;
      ++ list_fill(l, a) returns list having all elements equal
      ++ to \spad{a} of the same length as \spad{l}
    list_map2 : (LSI, LSI, (SI, SI) -> SI) -> LSI;
      ++ list_map2(l1, l2, f) creates list from values obtained
      ++ by applying f to corresponding elements of l1 and l2
      ++ Note: we truncate result to length of shorter list,
      ++ excess elements of l1 or l2 are ignored.
    list_add1 : (LSI, LSI) -> LSI;
    list_add2 : (LSI, LSI) -> LSI;
    list_add3 : (LSI, LSI) -> LSI;
    list_filter : (LSI, SI -> Boolean) -> LSI;
    filter_pos1 : LSI -> LSI;
    filter_pos2 : LSI -> LSI;
    filter_pos3 : PSI -> PSI;
    setelt3 : (PSI, LSI) -> Void
  ) == add

    list_map1(l : LSI, f : SI -> SI) : LSI ==
        [f(el) for el in l]

    -- helper for list_inc
    inc_SI(el : SI) : SI == el + 1

    list_inc(l : LSI) : LSI ==
        list_map1(l, inc_SI)

    arr_inc(pa : PSI) : PSI ==
        [pa(i) + 1 for i in 0..(#pa - 1)]

    list_fill(l : LSI, x : SI) : LSI ==
        list_map1(l, (y : SI) : SI +-> x)

    list_map2(l1 : LSI, l2 : LSI, f : (SI, SI) -> SI) : LSI ==
        [f(el1, el2) for el1 in l1 for el2 in l2]

    -- helper for list_add1
    add_SI(x1 : SI, x2 : SI) : SI == x1 + x2

    list_add1(l1 : LSI, l2 : LSI) : LSI ==
        list_map2(l1, l2, add_SI)

    list_add2(l1 : LSI, l2 : LSI) : LSI ==
        [el1 + el2 for el1 in l1 for el2 in l2]

    list_add3(l1 : LSI, l2 : LSI) : LSI ==
        list_map2(l1, l2, (x1 : SI, x2 : SI) : SI +-> x1 + x2)

    list_filter(l : LSI, f : SI -> Boolean) : LSI ==
        [el for el in l | f(el)]

    filter_pos1(l : LSI) : LSI ==
        [el for el in l | 0 < el]

    filter_pos2(l : LSI) : LSI ==
        list_filter(l, (x : SI) : Boolean +-> x > 0)

    filter_pos3(pa : PSI) : PSI ==
        [pa(i) for i in 0..(#pa - 1) | pa(i) > 0]

    setelt3(pa : PSI, l : LSI) : Void ==
        for i in 0..(#pa - 1) by 3 for el in l repeat
            pa(i) := el

